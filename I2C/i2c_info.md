# üì° I¬≤C (Inter-Integrated Circuit) Communication Protocol

## üß† What is I¬≤C?

**I¬≤C** (pronounced *I-squared-C* or *I-two-C*) stands for **Inter-Integrated Circuit**. It‚Äôs a **synchronous**, **multi-master**, **half-duplex**, **two-wire** communication protocol designed to connect **multiple ICs (chips)** over short distances, typically on a **PCB**.

---

## üîå I¬≤C Bus Basics

| Line Name | Function                          |
|-----------|-----------------------------------|
| **SDA**   | Serial Data (bidirectional)       |
| **SCL**   | Serial Clock (generated by master)|

- Only **two wires** are needed for communication.
- Devices are identified using **7-bit or 10-bit addresses**.
- Supports **multiple masters and slaves** on the same bus.

---

## üß± I¬≤C Roles

- **Master**: Initiates communication and generates clock (SCL).
- **Slave**: Responds to master‚Äôs request; each has a unique address.

> You can have **many slaves**, and sometimes even **multiple masters**.

---

## üß© I¬≤C Data Frame Format

I¬≤C communicates in **messages** composed of **frames**, with each frame consisting of 8 bits + 1 ACK bit.

### üßµ General I¬≤C Transfer

```
[START] ‚Üí [ADDRESS + R/W] ‚Üí [ACK] ‚Üí [DATA BYTE] ‚Üí [ACK] ‚Üí ... ‚Üí [STOP]
```

### üß± Frame Breakdown

| Section           | Description                              |
|-------------------|------------------------------------------|
| **START**         | Master pulls SDA LOW while SCL is HIGH   |
| **ADDRESS**       | 7 bits for slave address                 |
| **R/W Bit**       | 1 = Read, 0 = Write                      |
| **ACK/NACK**      | Acknowledgment bit from slave/master     |
| **DATA BYTE**     | 8 bits of data                           |
| **STOP**          | Master releases SDA while SCL is HIGH    |

---

## üîÑ Read vs Write Transaction

### üñãÔ∏è Write Example (Master to Slave)

```
START ‚Üí [ADDR + 0] ‚Üí ACK ‚Üí [DATA1] ‚Üí ACK ‚Üí [DATA2] ‚Üí ACK ‚Üí STOP
```

### üìñ Read Example (Slave to Master)

```
START ‚Üí [ADDR + 1] ‚Üí ACK ‚Üí [DATA1] ‚Üí ACK ‚Üí [DATA2] ‚Üí NACK ‚Üí STOP
```

- Master sends a **NACK** after final byte to signal **end of read**.

---

## üß∞ I¬≤C Usage & Applications

| Application                     | Examples                        |
|----------------------------------|----------------------------------|
| **Sensor communication**         | MPU6050, BMP280, BH1750         |
| **Real-time clocks (RTC)**       | DS1307, DS3231                  |
| **EEPROM / Flash memory**        | AT24C32, 24LC256                |
| **Displays**                     | OLEDs, LCDs with I¬≤C backpacks  |
| **GPIO expanders**               | PCF8574, MCP23017               |

---

## üìå I¬≤C Device Addressing

- Devices are assigned **7-bit addresses** (some use 10-bit).
- Some address bits may be configurable via **hardware pins (A0‚ÄìA2)**.
- For a 7-bit address like `0x68`, the write address is `0xD0`, and read is `0xD1` (appended with R/W bit).

---

## üìâ I¬≤C Speed Modes

| Mode          | Max Speed     |
|---------------|---------------|
| **Standard**  | 100 kHz       |
| **Fast**      | 400 kHz       |
| **Fast+**     | 1 MHz         |
| **High-speed**| 3.4 MHz       |

---

## üß™ I¬≤C Real-World Example (MPU6050)

### üß© Steps to Read from a Register

1. Master sends START
2. Sends slave address with write bit (0)
3. Sends register address to read
4. Sends REPEATED START
5. Sends slave address with read bit (1)
6. Reads data byte(s)
7. Sends STOP

> This is called a **repeated start** condition.

---

## üü© I¬≤C vs SPI vs UART

| Feature          | I¬≤C             | SPI              | UART           |
|------------------|------------------|-------------------|----------------|
| Wires            | 2                | 4+ (MOSI, MISO, SCLK, CS) | 2 (TX, RX)  |
| Data Direction   | Half-duplex      | Full-duplex       | Full-duplex    |
| Addressing       | Yes (7/10-bit)   | No (CS-based)     | No             |
| Speed            | Up to 3.4 MHz    | 10+ MHz possible  | Up to 1 Mbps+  |
| Master-Slave     | Multi-master     | Usually single master | No master/slave |
| Complexity       | Medium           | Low               | Very Low       |

---

## ‚úÖ Advantages of I¬≤C

| Advantage           | Description                            |
|---------------------|----------------------------------------|
| **Simple wiring**   | Only 2 lines needed for many devices   |
| **Addressable**     | Each device has a unique address       |
| **Multi-master**    | More than one controller possible      |
| **Widely used**     | Supported by most sensors and modules  |

---

## ‚ùå Disadvantages of I¬≤C

| Disadvantage         | Description                               |
|----------------------|-------------------------------------------|
| **Slower**           | Lower speeds than SPI                     |
| **Limited length**   | Best for short distances (<1m)            |
| **Bus contention**   | If multiple masters are not managed well  |
| **Requires ACKs**    | Communication breaks if ACKs not handled  |

---

## üõ†Ô∏è I¬≤C Wiring Example (Master and 2 Slaves)

```
        Master
        +-----+
SDA --->|     |
SCL --->|     |
        +-----+
           |
        +--+--+
        |     |
      +----+ +----+
      | S1 | | S2 |
      +----+ +----+

(All devices share SDA & SCL lines)
```

> Devices are identified by unique **7-bit addresses**, not by separate lines like SPI.

---

## üß† Summary

| Feature              | I¬≤C                                |
|----------------------|-------------------------------------|
| Topology             | Multi-master, multi-slave           |
| Wires Needed         | 2 (SDA, SCL)                        |
| Addressing           | 7-bit (or 10-bit)                   |
| Communication Type   | Half-duplex, synchronous            |
| Typical Use Case     | Sensor networks, IC communication   |
| Simplicity           | Moderate (some protocol handling)   |

---

## ‚öîÔ∏è I¬≤C Arbitration and Clock Synchronization

---

## üß† 1. I¬≤C Arbitration (Data Arbitration)

### üìå What is it?

Arbitration is a method that ensures only **one master** communicates at a time on a shared I¬≤C bus.

---

### üîÑ How it Works:

- Each master **monitors SDA** while transmitting
- If it sends a **HIGH (1)** but reads **LOW (0)**, it **loses arbitration**
- It **stops communication** immediately

### ‚úÖ Result:

- The **winning master** continues transmission
- The **losing master** silently waits

---

### üìò Example:

Two masters send:
- Master A: `01100000`
- Master B: `01101000`

At bit 5:
- A sends 0, B sends 1 ‚Üí SDA = 0 ‚Üí B loses arbitration

---

## üß† 2. Clock Synchronization

### üìå Why is it needed?

In multi-master systems, multiple clocks may exist. I¬≤C ensures synchronization using the **wired-AND nature** of the SCL line.

---

### üîß How it Works:

- All devices can **pull SCL LOW**
- None can **drive it HIGH** (open-drain)
- The final clock is the **logical AND** of all masters

> So, if any device pulls SCL LOW, the clock is LOW ‚Üí everyone waits

---

### üïë Clock Stretching

- **Slaves can hold SCL LOW** to delay the master
- Master waits until SCL goes HIGH (released by slave)

---

## ‚úÖ Summary

| Feature              | Description                                       |
|----------------------|---------------------------------------------------|
| **Arbitration**       | Master checks SDA for mismatch while transmitting |
| **Who wins?**         | The master that matches SDA keeps going          |
| **Clock Sync**        | Slowest device controls SCL timing               |
| **Clock Stretching**  | Slaves can delay communication by holding SCL LOW|

---

> These two features make I¬≤C a powerful and robust **multi-master, multi-slave** communication protocol.


## üïê Clock Stretching in I¬≤C

---

## ‚è∞ What is Clock Stretching?

**Clock stretching** is when a **slave device holds the SCL line LOW**, preventing the master from sending the next clock pulse.

> It allows the slave to delay the communication until it‚Äôs ready.

---

## üõ†Ô∏è How It Works

1. Master pulls SCL LOW ‚Üí begins a clock pulse
2. Master releases SCL HIGH ‚Üí ends the pulse
3. **Slave holds SCL LOW**
4. Master must **wait** until slave releases SCL
5. Only then can the master continue to the next bit

---

## üß™ Why Slaves Stretch the Clock?

| Scenario                        | Reason                        |
|----------------------------------|-------------------------------|
| Sensor needs conversion time     | ADC or sensor still measuring |
| EEPROM read                      | Internal memory fetch         |
| Buffer not ready                 | Data prep in progress         |
| I/O delay                        | Limited processing power      |

---

## üëÄ Does the Master Handle This?

- Master must **check if SCL is truly HIGH** before continuing
- Most hardware I¬≤C modules handle this **automatically**

---

## üìä Timing Visualization

```
SCL:  ‚îÄ‚îÄ‚îê__________‚îê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚Üê Slave holds SCL LOW (stretching)
         ‚Üë        ‚Üë
       Master    Slave
       releases  releases

SDA:  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚Üê Data paused
```

---

## ‚úÖ Good to Know

- Required for some devices
- Ignoring it can cause **data corruption**
- Fully supported by most platforms (STM32, Arduino, Raspberry Pi)

---

## üìé Summary

| Feature            | Description                                |
|--------------------|--------------------------------------------|
| Who                | Slave holds SCL LOW                        |
| Why                | Needs time to process                      |
| Master behavior    | Wait until SCL is HIGH                     |
| Risk if ignored    | Data loss, bus errors                      |
| Automatically handled | ‚úÖ Yes, by most I¬≤C drivers             |

---

> Clock stretching ensures I¬≤C communication is **reliable**, even with slower or memory-based slave devices.
