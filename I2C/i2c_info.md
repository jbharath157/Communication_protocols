# 📡 I²C (Inter-Integrated Circuit) Communication Protocol

## 🧠 What is I²C?

**I²C** (pronounced *I-squared-C* or *I-two-C*) stands for **Inter-Integrated Circuit**. It’s a **synchronous**, **multi-master**, **half-duplex**, **two-wire** communication protocol designed to connect **multiple ICs (chips)** over short distances, typically on a **PCB**.

---

## 🔌 I²C Bus Basics

| Line Name | Function                          |
|-----------|-----------------------------------|
| **SDA**   | Serial Data (bidirectional)       |
| **SCL**   | Serial Clock (generated by master)|

- Only **two wires** are needed for communication.
- Devices are identified using **7-bit or 10-bit addresses**.
- Supports **multiple masters and slaves** on the same bus.

---

## 🧱 I²C Roles

- **Master**: Initiates communication and generates clock (SCL).
- **Slave**: Responds to master’s request; each has a unique address.

> You can have **many slaves**, and sometimes even **multiple masters**.

---

## 🧩 I²C Data Frame Format

I²C communicates in **messages** composed of **frames**, with each frame consisting of 8 bits + 1 ACK bit.

### 🧵 General I²C Transfer

```
[START] → [ADDRESS + R/W] → [ACK] → [DATA BYTE] → [ACK] → ... → [STOP]
```

### 🧱 Frame Breakdown

| Section           | Description                              |
|-------------------|------------------------------------------|
| **START**         | Master pulls SDA LOW while SCL is HIGH   |
| **ADDRESS**       | 7 bits for slave address                 |
| **R/W Bit**       | 1 = Read, 0 = Write                      |
| **ACK/NACK**      | Acknowledgment bit from slave/master     |
| **DATA BYTE**     | 8 bits of data                           |
| **STOP**          | Master releases SDA while SCL is HIGH    |

---

## 🔄 Read vs Write Transaction

### 🖋️ Write Example (Master to Slave)

```
START → [ADDR + 0] → ACK → [DATA1] → ACK → [DATA2] → ACK → STOP
```

### 📖 Read Example (Slave to Master)

```
START → [ADDR + 1] → ACK → [DATA1] → ACK → [DATA2] → NACK → STOP
```

- Master sends a **NACK** after final byte to signal **end of read**.

---

## 🧰 I²C Usage & Applications

| Application                     | Examples                        |
|----------------------------------|----------------------------------|
| **Sensor communication**         | MPU6050, BMP280, BH1750         |
| **Real-time clocks (RTC)**       | DS1307, DS3231                  |
| **EEPROM / Flash memory**        | AT24C32, 24LC256                |
| **Displays**                     | OLEDs, LCDs with I²C backpacks  |
| **GPIO expanders**               | PCF8574, MCP23017               |

---

## 📌 I²C Device Addressing

- Devices are assigned **7-bit addresses** (some use 10-bit).
- Some address bits may be configurable via **hardware pins (A0–A2)**.
- For a 7-bit address like `0x68`, the write address is `0xD0`, and read is `0xD1` (appended with R/W bit).

---

## 📉 I²C Speed Modes

| Mode          | Max Speed     |
|---------------|---------------|
| **Standard**  | 100 kHz       |
| **Fast**      | 400 kHz       |
| **Fast+**     | 1 MHz         |
| **High-speed**| 3.4 MHz       |

---

## 🧪 I²C Real-World Example (MPU6050)

### 🧩 Steps to Read from a Register

1. Master sends START
2. Sends slave address with write bit (0)
3. Sends register address to read
4. Sends REPEATED START
5. Sends slave address with read bit (1)
6. Reads data byte(s)
7. Sends STOP

> This is called a **repeated start** condition.

---

## 🟩 I²C vs SPI vs UART

| Feature          | I²C             | SPI              | UART           |
|------------------|------------------|-------------------|----------------|
| Wires            | 2                | 4+ (MOSI, MISO, SCLK, CS) | 2 (TX, RX)  |
| Data Direction   | Half-duplex      | Full-duplex       | Full-duplex    |
| Addressing       | Yes (7/10-bit)   | No (CS-based)     | No             |
| Speed            | Up to 3.4 MHz    | 10+ MHz possible  | Up to 1 Mbps+  |
| Master-Slave     | Multi-master     | Usually single master | No master/slave |
| Complexity       | Medium           | Low               | Very Low       |

---

## ✅ Advantages of I²C

| Advantage           | Description                            |
|---------------------|----------------------------------------|
| **Simple wiring**   | Only 2 lines needed for many devices   |
| **Addressable**     | Each device has a unique address       |
| **Multi-master**    | More than one controller possible      |
| **Widely used**     | Supported by most sensors and modules  |

---

## ❌ Disadvantages of I²C

| Disadvantage         | Description                               |
|----------------------|-------------------------------------------|
| **Slower**           | Lower speeds than SPI                     |
| **Limited length**   | Best for short distances (<1m)            |
| **Bus contention**   | If multiple masters are not managed well  |
| **Requires ACKs**    | Communication breaks if ACKs not handled  |

---

## 🛠️ I²C Wiring Example (Master and 2 Slaves)

```
        Master
        +-----+
SDA --->|     |
SCL --->|     |
        +-----+
           |
        +--+--+
        |     |
      +----+ +----+
      | S1 | | S2 |
      +----+ +----+

(All devices share SDA & SCL lines)
```

> Devices are identified by unique **7-bit addresses**, not by separate lines like SPI.

---

## 🧠 Summary

| Feature              | I²C                                |
|----------------------|-------------------------------------|
| Topology             | Multi-master, multi-slave           |
| Wires Needed         | 2 (SDA, SCL)                        |
| Addressing           | 7-bit (or 10-bit)                   |
| Communication Type   | Half-duplex, synchronous            |
| Typical Use Case     | Sensor networks, IC communication   |
| Simplicity           | Moderate (some protocol handling)   |

---

## ⚔️ I²C Arbitration and Clock Synchronization

---

## 🧠 1. I²C Arbitration (Data Arbitration)

### 📌 What is it?

Arbitration is a method that ensures only **one master** communicates at a time on a shared I²C bus.

---

### 🔄 How it Works:

- Each master **monitors SDA** while transmitting
- If it sends a **HIGH (1)** but reads **LOW (0)**, it **loses arbitration**
- It **stops communication** immediately

### ✅ Result:

- The **winning master** continues transmission
- The **losing master** silently waits

---

### 📘 Example:

Two masters send:
- Master A: `01100000`
- Master B: `01101000`

At bit 5:
- A sends 0, B sends 1 → SDA = 0 → B loses arbitration

---

## 🧠 2. Clock Synchronization

### 📌 Why is it needed?

In multi-master systems, multiple clocks may exist. I²C ensures synchronization using the **wired-AND nature** of the SCL line.

---

### 🔧 How it Works:

- All devices can **pull SCL LOW**
- None can **drive it HIGH** (open-drain)
- The final clock is the **logical AND** of all masters

> So, if any device pulls SCL LOW, the clock is LOW → everyone waits

---

### 🕑 Clock Stretching

- **Slaves can hold SCL LOW** to delay the master
- Master waits until SCL goes HIGH (released by slave)

---

## ✅ Summary

| Feature              | Description                                       |
|----------------------|---------------------------------------------------|
| **Arbitration**       | Master checks SDA for mismatch while transmitting |
| **Who wins?**         | The master that matches SDA keeps going          |
| **Clock Sync**        | Slowest device controls SCL timing               |
| **Clock Stretching**  | Slaves can delay communication by holding SCL LOW|

---

> These two features make I²C a powerful and robust **multi-master, multi-slave** communication protocol.


## 🕐 Clock Stretching in I²C

---

## ⏰ What is Clock Stretching?

**Clock stretching** is when a **slave device holds the SCL line LOW**, preventing the master from sending the next clock pulse.

> It allows the slave to delay the communication until it’s ready.

---

## 🛠️ How It Works

1. Master pulls SCL LOW → begins a clock pulse
2. Master releases SCL HIGH → ends the pulse
3. **Slave holds SCL LOW**
4. Master must **wait** until slave releases SCL
5. Only then can the master continue to the next bit

---

## 🧪 Why Slaves Stretch the Clock?

| Scenario                        | Reason                        |
|----------------------------------|-------------------------------|
| Sensor needs conversion time     | ADC or sensor still measuring |
| EEPROM read                      | Internal memory fetch         |
| Buffer not ready                 | Data prep in progress         |
| I/O delay                        | Limited processing power      |

---

## 👀 Does the Master Handle This?

- Master must **check if SCL is truly HIGH** before continuing
- Most hardware I²C modules handle this **automatically**

---

## 📊 Timing Visualization

```
SCL:  ──┐__________┐──────   ← Slave holds SCL LOW (stretching)
         ↑        ↑
       Master    Slave
       releases  releases

SDA:  ────────────────     ← Data paused
```

---

## ✅ Good to Know

- Required for some devices
- Ignoring it can cause **data corruption**
- Fully supported by most platforms (STM32, Arduino, Raspberry Pi)

---

## 📎 Summary

| Feature            | Description                                |
|--------------------|--------------------------------------------|
| Who                | Slave holds SCL LOW                        |
| Why                | Needs time to process                      |
| Master behavior    | Wait until SCL is HIGH                     |
| Risk if ignored    | Data loss, bus errors                      |
| Automatically handled | ✅ Yes, by most I²C drivers             |

---

> Clock stretching ensures I²C communication is **reliable**, even with slower or memory-based slave devices.
